---
title: "Business Analytics Course 2020"
author: "Evgeniia Golovina"
date: "24/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Business Analytics Course 2020 (Udemy)

Section 3. Entering and Reading data. Data Import and Export

```{r s3}
# reading csv, txt files
?read.csv; ?read.table

# reading xlsx files
library(xlsx)
ex <- read.xlsx('test.xlsx', sheetIndex = 1)

# reading google sheets
library(gsheet)
url <- "url_to_google_sheet"
gdata <- as.data.frame(gsheet2tbl(url))

# reading other formats (e.g. .R, .RData, .tab, .csv)
?data()

# exporting data
?write.csv()
```

Section 4. Operators in R

There are four types of operators:
1. Assignment operators (=, <-, ->, <<-, ->>)
2. Arithmetic operators (+, -, *, /, %%, %/%, ^)
3. Relational operators (<, >, ==, <=, >=, !=)
4. Logical operators (&, |, !, &&, ||)

```{r s4}
h <- 10; i <<- 11; j = 12; 13 -> k; 14 ->> l

x = 5; y = 2
x + y; x - y; x * y; x / y; x ^ y
x %% y # gives the reminder
x%/%y # gives the quotient

# Compares all the elements
c(T, T, F) & c(T, F, F) # T T F
c(T, T, F) | c(T, F, F) # T T F

# Element wise comparing; compares on first elements of each vector
c(T, T, F) && c(T, F, F) # T
c(T, T, F) && c(F, F, F) # F
c(T, T, F) || c(F, F, F) # T
```

Section 5. Data Types and Data Structures

Data types: character, numeric, integer, logical, complex.
Data structeres: vectors, matrices, arrays, lists, data frames.

```{r s5}
# vector: one data type
x <- c(2, 3, 4); class(x); length(x); typeof(x)
seq(10); seq(1, 10, 1.5)

# matrix: one data type
m <- matrix(nrow = 2, ncol = 2) # create an empty matrix
m <- matrix(1:10, nrow = 2, ncol = 5)
dim(m)
# adding values by row
m <- matrix(1:6, nrow=3, byrow=TRUE, dimnames = list(c("d", "e", "f"), c("a", "b")))
# adding values by column
m <- matrix(1:6, nrow=3, byrow=FALSE, dimnames = list(c("d", "e", "f"), c("a", "b")))
# other way to construct a matrix
m <- 1:10; dim(m) = c(5, 2)
# adding column to a matrix (cbind)
c = c(7, 8, 9, 10, 11); m1 <- cbind(m, c)
# adding row to a matrix (rbind)
c = c(1, 1, 1); m2 <- rbind(m1, c)

# list: different data types
v1 = 1:5; v2 = month.abb[4:10]; v3 = c(T, F, T, F)
comb = c(v1, v2, v3) # all converted to characters by default
l1 <- list(v1, v2, v3) # each vector preserve its data type

# array: only one data type; stores data in more than 2 dimensions
v1 <- c(1, 2, 3); v2 <- c(10, 11, 12, 13, 14, 15)
column.names <- c("col1", "col2", "col3"); row.names <- c("row1", "row2", "row3")
matrix.names <- c("m1", "m2")
# create an array with two matrices of 3 columns and 3 rows each
a <- array(c(v1, v2), dim = c(3, 3, 2), dimnames = list(row.names, column.names, matrix.names))

# data frame: different data types; stores data in more than 2 dimensions
df <- data.frame(name = c("N1", "N2", "N3"), age = c(10, 12, 14)); df
# create a dataframe using vectors
v1 <- 1:10; v2 <- paste("N", 1:10, sep=''); v3 <- round(rnorm(10, mean=25, sd=2),1)
v4 = sample(c("M", "F"), size=10, replace=T)
df <- data.frame(v1, v2, v3, v4); df
```

Section 6. Handling packages in R

```{r s6}
# installing packages
install.packages("pacman")
install.packages(c("dplyr", "plotly"))

# loading packages
library(dplyr)
require(plotly)
pacman::p_load(dplyr, plotly) # to load multiple packages

# viewing loaded packages
search()

# uloading packages
detach("package:plotly", unload = TRUE)

# removing packages
remove.packages("plotly")

# updating packages
update.packages()
update.packages(oldPkgs = c("dplyr", "plotly"))
```

Section 7. Subsetting Data in R

Three methods: 1) square bracket notation 2) subset function 3) which() and bracket notation

```{r s7}
## 1. square bracket notation
df <- matrix(1:12, nrow = 4, byrow = F); df
df[1, ] # subsetting the first row
df[, 3] # subsetting the third column
df[1:3, 2]

x <- c(2, 4, 3, 5); x[c(3, 1)] # extracting the third and first elements
x[-c(3, 1)] # extracting elements except the third and first elements
x[c(T, T, F, F)] # selecting elements where logical value is TRUE
x[x > 3]
x[] # returns the original vector

y <- setNames(x, letters[1:4])
y[c("d", "c", "a")]

m <- matrix(1:9, nrow = 3); colnames(m) <- c("a", "b", "c"); m
m[1:2,]; m[3,3]

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3]); df
df[df$x==2, ]

## 2. subset function
set.seed(1234)
x <- round(matrix(rnorm(30, 1), ncol = 5), 2); y <- c(1, seq(5))
m <- cbind(x, y) # combining x and y into one matrix
df <- data.frame(m) # converting to dataframe
subset(df, y > 2) # subsetting rows
subset(df, y > 2 & V1 > 0.2) # subsetting rows
subset(df, y > 2 & V1 > 0.2, select = c(V1, V4)) # subsetting both rows and columns

## 3. which() and bracket notation
which(letters=="z") # getting the position of (26)
which(letters=="s") # getting the position of s (19)
which(women$height==66) # 9
which(women$height>=70) # 13, 14, 15

v1 <- c(2, 3, 1, 4, 5, 6, 7, 10, 12, 13, 20)
v1 > 6 # logical
which(v1 > 6) # getting the positions where the value is TRUE
v1[which(v1 > 6)] # getting the actual values

names <- c("jack", "jill", "tom", "buggs", "bunny")
grep('[bu]', names, ignore.case = T); names[grep('[bu]', names, ignore.case = T)]

mtcars[which(mtcars$mpg > 25), ]
```

Section 8. Descriptive Statistics

```{r s8}
mean(mtcars$mpg) # mean
median(mtcars$mpg) # meadian
sd(mtcars$mpg) # standard deviation: how far the data is spread out in comparison to the mean value
var(mtcars$mpg) # variance: how far the data is spread out
min(mtcars$mpg) # minimum
max(mtcars$mpg) # maximum
range(mtcars$mpg) # range of values
summary(mtcars$mpg) # summary statistics
quantile(mtcars$mpg, probs = seq(0, 1, 0.25)) # sample quantiles
rowSums(mtcars); colSums(mtcars) # row and column sums
rowMeans(mtcars); colMeans(mtcars)# row and column means
```

Section 9. Apply Family in R

apply(), lapply(), sapply(), mapply(), tapply()

```{r s9}
## apply() operates on arrays, dataframes or matrices; returns a vector or a list
df <- data.frame(first = c(1:10), second = c(11:20)); df
apply(df, 2, mean) # apply mean function for columns (2)
apply(df, 1, mean) # apply mean function for rows (1)

x <- cbind(x1 = 3, x2 = c(4:1, 2:5)); x
dimnames(x)[[1]] <- letters[1:8]; x
apply(x, 2, mean)
col.sums <- apply(x, 2, sum); col.sums
row.sums <- apply(x, 1, sum); row.sums
apply(x, 2, sort)

## lapply() operates on dataframes, lists or vectors; returns a list
a <- matrix(1:9, nrow=3, byrow=F); b <- matrix(4:15, nrow=4, byrow = F)
c <- data.frame(x=c(8,9,10), y=c(8,9,10))
mylist <- list(a, b, c); mylist # a list of two matrices and one dataframe
lapply(mylist, "[", , 2) # extracting the 2nd column from mylist with the selection operator "["
lapply(mylist, "[", 1, ) # extracting the first row from mylist
lapply(mylist, "[", 1, 2) # extracting the first element from the 2nd column of each matrix/dataframe

## sapply() operates on dataframes, lists or vectors; returns a vector
sapply(mylist, "[", 1, 2) # returns a list

## tapply() operates on vectors; returns
am1 <- mtcars[, 'am']; amcyl1 <- mtcars[, c('cyl', 'am')]; mpg1 <- mtcars[, c('mpg')]
tapply(mpg1, am1, mean) # mean mpg of each am type
tapply(mpg1, amcyl1, mean) # mean mpg of each am and cyl type

?rep() # replicating elements of vectors and lists
Z <- sapply(mylist, "[", 1, 1); Z
x <- rep(Z, c(3, 1, 2)) # repeating the 1st element of z three times, 2nd - two times, 3rd - two times

## mapply() operates on multiple lists; multivariate apply
m <- matrix(c(rep(1,4), rep(2,4), rep(3,4), rep(4,4)),4,4); m
m1 <- mapply(rep, 1:4, 4); m1
mapply(sum, 1:4, 1:4, 1:4) # sum up the 1st elements of vectors, then the 2nd elements etc...
```

Section 10. Aggregate and Table Commands

Aggregate function is used to compute a statistical summary of a subsetted dataframe defined by a list of grouping elements. Table function is used to create frequency tables with condition.

```{r s10}
## aggregate function
?aggregate
data <- ChickWeight; dim(data)
# aggregating the mean by weight depending on diet
aggregate(data$weight, by = list(diet = data$Diet), FUN = "mean")
# aggregating the mean by weight depending on time and diet
aggregate(data$weight, by = list(time = data$Time, diet = data$Diet), FUN = "mean")

## table function
?table # performs categorical tabulation of data with the variable
table(mtcars$cyl); table(mtcars$cyl, mtcars$gear)
t1 <- table(mtcars$cyl, mtcars$gear, dnn = c('cyl', 'gear')); t1 # dnn - dimension names
margin.table(t1) # summs values over margins - total sum of table
margin.table(x=t1, margin=1) # cylinder-wise (row)
margin.table(x=t1, margin=2) # gear-wise (column)
addmargins(A=t1, margin=1) # sum of each column shown as row
addmargins(A=t1, margin=2, FUN=mean) # mean of each row as a column
addmargins(A=t1, margin=c(1,2), FUN=sum) # sum at both row and column
addmargins(A=t1, margin=c(1,2), FUN=c(sum,mean)) # two function on row/column margins
addmargins(A=t1, margin=c(1,2), FUN=list(list(sum,mean,length,sd),list(sd,sum)))
prop.table(t1) # convert a frequency table into proportions
prop.table(t1, margin=1) # sum of each row = 1
rowSums(prop.table(t1,margin=1))
prop.table(t1, margin=2) # sum of each column = 1
colSums(prop.table(t1,margin=2))
matrix(paste(prop.table(x=t1)*100, "%", sep=''), ncol=3)
```

Section 11. Data Manipulation in R using dplyr

summarise(), mutate(), transmute(), select(), filter(), arrange(), slice(), rename(), relocate() functions.

```{r s11}
library(dplyr); vignette("dplyr")
df <- mtcars
### Columns
## select - to select the columns based on conditions
f = c('cyl', 'vs', 'am', 'gear', 'carb')
df[f] = lapply(df[f], factor, ordered=T) # converting variables into factors
sapply(df, class) # checking the class of the variables
sapply(df[f], table) # combining in single command
select(mtcars, mpg)
x <- mtcars %>% select(mpg); x
y <- mtcars %>% select(mpg, cyl, am); y

## rename - to change the name of columns
x <- x %>% rename(MPG = mpg); y <- y %>% rename(MPG = mpg, AM = am)

## mutate - to add new variables and preserve existing ones
median(airquality$Temp)
mutate(airquality, TempInC = (Temp - 32) * 5 / 9) # adding new column for temp in celsius

## transmute - to only keep the new variables
starwars %>% transmute(height_m = height / 100, BMI = mass / (height_m^2))

## relocate - to change the order of the columns
starwars %>% relocate(sex:homeworld, .before = height)

### Rows
## filter - to filter the rows based on conditions
?filter
filter(df, cyl == 6)
df %>% filter(carb>4)
df %>% filter(mpg>mean(mpg))
df %>% filter(mpg>2,carb>4)

## slice - to choose rows based on location
starwars %>% slice(5:10) # get values from row numbers 5 through 10
starwars %>% slice_head(n = 3) # select first three rows
starwars %>% slice_tail(n = 3) # select last three rows
starwars %>% slice_sample(n = 5) # randomly select rows

## arrange - to reorder (or sort) rows by one or more variables
?arrange
df %>% arrange(desc(cyl)) # descending order for cyl
df %>% group_by(cyl) %>% arrange(desc(mpg)) # descending order for mpg
starwars %>% filter(!is.na(height)) %>% slice_max(height, n = 3) # select rows with highest value

## Groups of rows
## summarise - to summarise multiple values into a single value
?summarise
df %>% summarise(disp = mean(disp), hp = mean(hp))
df %>% group_by(cyl) %>% summarise(means = mean(disp), n = n()) # to get counts
arrange(df, cyl, desc(disp))
```

Section 12. Summarising the data graphically

There are scatterplot, boxplot, histogram, barplot, line graph, pie chart.

Aesthetics options:
1) color: col, col.axis, col.lab, col.main, col.sub, fg, bg
2) line: lty and lwd
3) plotting symbol: pch
4) text and symbol size: cex, cex.axis, cex.lab, cex.main, cex.sub

```{r s12}
## scatterplot
x <- 1:10; y <- x^2
plot(x=x, y=y, type="p") # ponts
plot(x=x, y=y, type="l") # lines
plot(x=x, y=y, type="b") # both points and lines
plot(x=x, y=y, type="b", lwd=1, col="red", cex=1)
plot(x=x, y=y, xlim=c(0,20), ylim=c(0,100), type="b", lwd=1, col="red", cex=1)

plot(mtcars$wt, mtcars$mpg, col="blue", pch=20, cex=1.5)
plot(mtcars$wt, mtcars$mpg, col=mtcars$cyl, pch=mtcars$gear, cex=1.5, xlab="weight", ylab="Mileage",
     main="Weight vs Mileage") # adding multiple dimensions
abline(lm(mtcars$mpg~mtcars$wt), col="red") # adding fit line

lapply(mtcars[,c("cyl", "gear", "am")], table)
plot(mtcars$wt, mtcars$mpg, col=c(1,2,3), pch=c(20,21,22), cex=c(1,2), xlab="Weight", ylab="Mileage",
     main="Weight vs Mileage")
legend("topright", legend=c("Cyl-4", "Cyl-6", "Cyl-8"), pch=10, col=1:3, title="Cylinder")
legend("bottomleft", inset=.02, legend=c("Gear-3", "Gear-4", "Gear-5"), pch=20:23, title="Gear")
legend("top", legend=c("Auto", "Manual"), pch=c(20,21), pt.cex=c(1,1.5), title="Tx Type")

## pair plot
my_cols <- c("red", "blue", "green")
pairs(mtcars, pch=19, cex=0.5, col=my_cols[mtcars$carb], lower.panel=NULL)

## boxplot
boxplot(mtcars$mpg, col="green")
abline(h=mean(mtcars$mpg))
abline(h=quantile(mtcars$mpg))
boxplot(mtcars$mpg, col="green", horizontal = TRUE)

boxplot(count ~ spray, data=InsectSprays, col="red")
# to compare groups. If two boxes notches do not overlap --> strong evidence their medians differ
boxplot(count ~ spray, data=InsectSprays, notch=TRUE, col="blue")

## barplot
cars <- c(1,3,6,4,9); trucks <- c(2,5,4,5,12); suvs <- c(4,4,6,6,16)
data <- data.frame(cars, trucks, suvs)
barplot(data$cars, main="Auto data", xlab="Days", ylab="Total",
        names.arg=c("Mon", "Tue", "Wed", "Thu", "Fri"),
        border="blue", density=c(10, 20, 30, 40, 50))
barplot(as.matrix(data), main="Auto data", ylab="Total", beside=TRUE, col=rainbow(5))
legend("topleft", c("Mon", "Tue", "Wed", "Thu", "Fri"), cex=1, bty="n", fill=rainbow(5))
# transpose the data
barplot(t(data), main="Auto data", ylab="Total", col=heat.colors(3), space=0.1, cex.axis=0.8, las=1,
        names.arg=c("Mon", "Tue", "Wed", "Thu", "Fri"), cex=0.8)
legend("topleft", c("Cars", "Trucks", "Suvs"), cex=1, bty="n", fill=heat.colors(3))

## histogram
hist(rnorm(1000))
hist(islands)
hist(islands, probability=TRUE)
hist(islands, breaks=5, main="Islands histogram", xlab="area range", border="red", col="gray")

hist(airquality$Temp)
# adding label names and title
hist(airquality$Temp, main="Temp histogram", xlab="Temp", ylab="Temp frequency", las=1)
hist(airquality$Temp, main="Temp histogram", xlab="Temp", ylab="Temp frequency", las=1, 
     col=c("blue", "red"))
# removing all the annotations
hist(airquality$Temp, axes=F, ann=F, labels=T, ylim=c(0,35), col=c("blue", "red"))
hist(airquality$Temp, main="Temp histogram", xlab="Temp", ylab="Temp frequency", las=1, 
     col=c("blue", "red"), xlim=c(55,100), ylim=c(0,40), density=80)
# changing frequency
hist(airquality$Temp, breaks=20, main="Temp histogram", xlab="Temp", ylab="Temp frequency", las=1, 
     col=c("blue", "red"), labels=T, ylim=c(0,25))
# changing frequency on y axis
hist(airquality$Temp, breaks=20, freq=F, main="Temp histogram", xlab="Temp", ylab="Temp frequency",
     las=1, col=c("blue", "red"), labels=T)
lines(density(airquality$Temp), lwd=4, col="red") # adding density line: how the graph is moving

## pie chart
cars <- c(1,3,6,4,9)
pie(cars)
pie(cars, main="Cras", col=rainbow(length(cars)), labels=c("Mon", "Tue", "Wed", "Thu", "Fri"))

colors <- c("white", "grey70", "grey90", "grey50", "black")
car_labels <- round(cars/sum(cars)*100, 1)
car_labels <- paste(car_labels, "%", sep="")
pie(cars, main="Cras", col=colors, labels=car_labels, cex=0.8)
legend("topright", c("Mon", "Tue", "Wed", "Thu", "Fri"), cex=0.8, fill=colors)

## 3D exploded pie chart
library(plotrix)
slices <- c(10,12,4,16,8); lbls <- c("A", "B", "C", "D", "E")
pie3D(slices, labels=lbls, explode = 0.1,main="3D pie chart")
```

Section 13. GGplot - GRaphical Analysis

```{r s13}


```

Section 14. Simple Linear Regression

```{r s14}


```

Section 15. Multi-Linear Regression

```{r s15}


```



